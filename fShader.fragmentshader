#version 330 core

// Interpolated values from the vertex shaders
in vec2 UV;
in vec4 ShadowCoord;

in vec3 Position_worldspace;
in vec3 Normal_cameraspace;
in vec3 EyeDirection_cameraspace;
in vec3 LightDirection_cameraspace;
in vec3 LightDirection_cameraspace2;
in vec3 LightDirection_cameraspace3;

// Ouput data
layout(location = 0) out vec3 color;

// Values that stay constant for the whole mesh.
uniform vec3 LightPosition_worldspace;
uniform vec3 LightPosition_worldspace2;
uniform vec3 LightPosition_worldspace3;
uniform sampler2D myTextureSampler;

vec3 calLight(vec3 LightDirection_cameraspace,
	vec3 LightPosition_worldspace,
	float LightPower) 
{
	// Light emission properties
	vec3 LightColor = vec3(0.8,0.8,0.8);

	// Material properties
	vec3 MaterialDiffuseColor = texture( myTextureSampler, UV ).rgb;
	vec3 MaterialSpecularColor = vec3(0.3,0.3,0.3);

	// Use for simple light source attenuation
	// Atten = 1 / d^2
	float distance = length(LightPosition_worldspace - Position_worldspace) / 2;

	// Normal vector at point (normalized)
	vec3 n = normalize(Normal_cameraspace);
	// Light source vector (normalized)
	vec3 l = normalize(LightDirection_cameraspace);
	// Cosine of the angle between the normal and the light direction, 
	// clamped above 0
	//  - light is at the vertical of the triangle -> 1
	//  - light is perpendicular to the triangle -> 0
	//  - light is behind the triangle -> 0
	float cosTheta = clamp( dot(n,l), 0,1 );

	// Diffuse : kd * Ld * (n.l) * atten
	vec3 diffuse = MaterialDiffuseColor * (LightColor * LightPower) * cosTheta / (distance*distance);

	// Eye vector (towards the camera)
	vec3 v = normalize(EyeDirection_cameraspace);
	// Direction in which the triangle reflects the light
	vec3 r = reflect(-l,n);
	// Cosine of the angle between the Eye vector and the Reflect vector,
	// clamped to 0
	//  - Looking into the reflection -> 1
	//  - Looking elsewhere -> < 1
	float cosAlpha = clamp( dot(v,r), 0,1 );

	// Specular : ks * Ls * (v.r)^n * att
	vec3 specular = MaterialSpecularColor * (LightColor) * pow(cosAlpha,10) / (distance*distance);
	
	return diffuse + specular;
}

void main()
{
	// Ambient
	// Light emission properties
	vec3 LightColor = vec3(0.8,0.8,0.8);
	// Material properties
	vec3 MaterialAmbientColor = vec3(0.2,0.2,0.2);

	vec3 ambient = MaterialAmbientColor * LightColor;

	// Three light point
	// Side light with light power 180 & 120 (in 255).
	vec3 result = calLight(LightDirection_cameraspace, LightPosition_worldspace, 180f);
	result = result + calLight(LightDirection_cameraspace2, LightPosition_worldspace2, 120f);

	// Back light with light power 60 (in 255).
	result = result + calLight(LightDirection_cameraspace3, LightPosition_worldspace3, 70f);
	
	// Frag color
	color = ambient + result;
}